/**
 * Motor del Modo Desaf√≠o - Sistema independiente de juego
 * Maneja toda la l√≥gica espec√≠fica del modo desaf√≠o
 */
class ChallengeEngine {
    constructor() {
        this.isActive = false;        this.config = {
            difficulty: 'medium',
            timer: 20,
            mode: 'survival', // Modo supervivencia por defecto
            categories: {
                historia: true,
                ciencia: true,
                deportes: true,
                arte: true,
                geografia: true,
                entretenimiento: true
            }
        };        this.gameState = {
            currentQuestion: null,
            score: 0,
            streak: 0,
            questionsAnswered: 0,
            correctAnswers: 0,
            timeRemaining: 0,
            gameStartTime: null,
            isGameRunning: false,
            lives: 1, // Modo supervivencia: una sola vida
            isAlive: true // Estado de supervivencia
        };
        this.timerInterval = null;
        this.apiClient = null;
    }    /**
     * Inicializa el motor de desaf√≠o con la configuraci√≥n especificada
     * @param {Object} config - Configuraci√≥n del desaf√≠o
     */
    async initialize(config) {
        console.log('üöÄ Inicializando Modo Desaf√≠o...');
        
        // Track configuraci√≥n del desaf√≠o
        if (window.trivialAnalytics) {
            window.trivialAnalytics.trackChallengeSetup(
                config.mode || 'survival',
                config.timer || 20,
                config.questionCount || 0
            );
        }
        
        // Actualizar configuraci√≥n
        this.config = { ...this.config, ...config };
        
        // Inicializar cliente API
        if (!this.apiClient) {
            console.log('üîß Creando nueva instancia de ApiClient...');
            this.apiClient = new ApiClient();
        }
        
        // Probar conexi√≥n con la API
        //const apiWorking = await this.testApiConnection();
        //console.log(`üì° Estado de la API: ${apiWorking ? 'Funcionando' : 'Con problemas'}`);
        
        // Resetear estado del juego
        this.resetGameState();
        
        console.log('‚úÖ Modo Desaf√≠o inicializado:', this.config);
        return true;
    }/**
     * Resetea el estado del juego a valores iniciales
     */    resetGameState() {
        this.gameState = {
            currentQuestion: null,
            score: 0,
            streak: 0,
            questionsAnswered: 0,
            correctAnswers: 0,
            timeRemaining: this.config.timer || 0, // 0 significa tiempo ilimitado
            gameStartTime: null,
            isGameRunning: false,
            lives: 1, // Modo supervivencia: una sola vida
            isAlive: true // Estado de supervivencia
        };
    }

    /**
     * Inicia una nueva partida de desaf√≠o
     */
    async startChallenge() {
        console.log('üéØ Iniciando nuevo desaf√≠o...');
        
        try {
            this.resetGameState();
            this.gameState.gameStartTime = Date.now();
            this.gameState.isGameRunning = true;
            this.isActive = true;

            // Track inicio del desaf√≠o
            if (window.trivialAnalytics) {
                window.trivialAnalytics.trackChallengeStart(
                    this.config.mode || 'survival',
                    this.config.timer || 20
                );
            }

            // Cargar primera pregunta
            await this.loadNextQuestion();
            
            // Iniciar temporizador
            this.startTimer();
            
            // Disparar evento de inicio
            this.dispatchEvent('challengeStarted', {
                config: this.config,
                gameState: this.gameState
            });

            console.log('‚úÖ Desaf√≠o iniciado correctamente');
            return true;

        } catch (error) {
            console.error('‚ùå Error al iniciar desaf√≠o:', error);
            
            // Track error en analytics
            if (window.trivialAnalytics) {
                window.trivialAnalytics.trackError('CHALLENGE_START_ERROR', error.message);
            }
            
            this.dispatchEvent('challengeError', { error: error.message });
            return false;
        }
    }    /**
     * Carga la siguiente pregunta del desaf√≠o
     */
    async loadNextQuestion() {
        try {
            // Obtener categor√≠as habilitadas
            const enabledCategories = Object.keys(this.config.categories)
                .filter(cat => this.config.categories[cat]);

            if (enabledCategories.length === 0) {
                throw new Error('No hay categor√≠as seleccionadas');
            }            // Seleccionar categor√≠a aleatoria
            const randomCategory = enabledCategories[Math.floor(Math.random() * enabledCategories.length)];
            
            // Obtener dificultad efectiva (puede ser aleatoria)
            const effectiveDifficulty = this.getEffectiveDifficulty();
            console.log(`üé≤ Categor√≠a seleccionada: ${randomCategory}, dificultad: ${effectiveDifficulty}`);
            
            let question = null;

            try {
                // Intentar cargar pregunta de la API
                console.log('üîÑ Solicitando pregunta a la API...');
                const questions = await this.apiClient.getQuestions(randomCategory, effectiveDifficulty, 1);
                console.log('üì¶ Respuesta de la API:', questions);
                  if (questions && questions.length > 0) {
                    const apiQuestion = questions[0];
                    console.log('üîß Pregunta antes de conversi√≥n:', apiQuestion);
                    question = this.convertApiQuestionToChallengeFormat(apiQuestion, effectiveDifficulty);
                    console.log('‚úÖ Pregunta despu√©s de conversi√≥n:', question);
                }
            } catch (apiError) {
                console.warn('‚ö†Ô∏è Error de API, intentando con pregunta de prueba:', apiError);
            }            // Si no se pudo obtener de la API, usar pregunta de prueba
            if (!question) {
                console.log('üß™ Usando pregunta de prueba...');
                question = this.createTestQuestion(effectiveDifficulty);
            }this.gameState.currentQuestion = question;
            this.gameState.timeRemaining = this.config.timer || 0; // 0 para tiempo ilimitado

            // Disparar evento de nueva pregunta
            this.dispatchEvent('newChallengeQuestion', {
                question: question,
                gameState: this.gameState
            });

            console.log('üìù Nueva pregunta cargada exitosamente:', question.pregunta);

        } catch (error) {
            console.error('‚ùå Error cr√≠tico al cargar pregunta:', error);
            console.error('Stack trace:', error.stack);
              // Como √∫ltimo recurso, usar una pregunta de emergencia
            const emergencyQuestion = {
                pregunta: "¬øFunciona el modo desaf√≠o?",
                opciones: ["S√≠", "No", "Tal vez", "Error"],
                respuesta_correcta: "S√≠",
                categoria: "test",
                dificultad: effectiveDifficulty || "easy",
                fuente: "emergency"
            };this.gameState.currentQuestion = emergencyQuestion;
            this.gameState.timeRemaining = this.config.timer || 0; // 0 para tiempo ilimitado

            this.dispatchEvent('newChallengeQuestion', {
                question: emergencyQuestion,
                gameState: this.gameState
            });

            console.log('üö® Pregunta de emergencia cargada');
        }
    }    /**
     * Convierte una pregunta del formato API al formato esperado por el desaf√≠o
     * @param {Object} apiQuestion - Pregunta en formato API
     * @returns {Object} Pregunta en formato del desaf√≠o
     */    convertApiQuestionToChallengeFormat(apiQuestion, effectiveDifficulty = null) {
        console.log('üîÑ Convirtiendo pregunta de API:', apiQuestion);
          // Verificar si es formato API (con campo 'question') o fallback (con campo 'question' tambi√©n)
        if (apiQuestion.question && apiQuestion.answers) {
            // Formato API o fallback moderno
            const convertedQuestion = {
                pregunta: apiQuestion.question,
                opciones: apiQuestion.answers,
                respuesta_correcta: apiQuestion.answers[apiQuestion.correct],
                categoria: apiQuestion.category || 'general',
                dificultad: effectiveDifficulty || apiQuestion.difficulty || 'medium',
                fuente: apiQuestion.source || 'api',
                // PRESERVAR LA INFORMACI√ìN ORIGINAL DE LA API
                originalQuestion: apiQuestion.originalQuestion || apiQuestion.question,
                originalAnswers: apiQuestion.originalAnswers || apiQuestion.answers,
                // Si hay una versi√≥n traducida, incluirla
                translatedQuestion: apiQuestion.translatedQuestion || apiQuestion.question,
                translatedAnswers: apiQuestion.translatedAnswers || apiQuestion.answers            };
            
            // Debug: Verificar si hay diferencias reales entre original y traducido
            const hasOriginalDifferences = convertedQuestion.originalQuestion !== convertedQuestion.pregunta ||
                JSON.stringify(convertedQuestion.originalAnswers) !== JSON.stringify(convertedQuestion.opciones);
            
            console.log('üîç Verificaci√≥n de diferencias:', {
                originalQuestion: convertedQuestion.originalQuestion,
                translatedQuestion: convertedQuestion.pregunta,
                originalAnswers: convertedQuestion.originalAnswers,
                translatedAnswers: convertedQuestion.opciones,
                hasOriginalDifferences: hasOriginalDifferences
            });
            
            console.log('‚úÖ Pregunta convertida con informaci√≥n original preservada:', convertedQuestion);
            return convertedQuestion;
        } else {
            // Intentar otros formatos posibles
            console.warn('Formato de pregunta desconocido:', apiQuestion);
            const convertedQuestion = {
                pregunta: apiQuestion.pregunta || apiQuestion.question || 'Pregunta no disponible',
                opciones: apiQuestion.opciones || apiQuestion.answers || [],
                respuesta_correcta: apiQuestion.respuesta_correcta || (apiQuestion.opciones ? apiQuestion.opciones[0] : 'Sin respuesta'),
                categoria: apiQuestion.categoria || apiQuestion.category || 'general',
                dificultad: effectiveDifficulty || apiQuestion.dificultad || apiQuestion.difficulty || 'medium',
                fuente: apiQuestion.fuente || apiQuestion.source || 'unknown',
                // PRESERVAR LA INFORMACI√ìN ORIGINAL
                originalQuestion: apiQuestion.originalQuestion || apiQuestion.pregunta || apiQuestion.question || 'Pregunta no disponible',
                originalAnswers: apiQuestion.originalAnswers || apiQuestion.opciones || apiQuestion.answers || []
            };
            
            console.log('‚ö†Ô∏è Pregunta de formato desconocido convertida:', convertedQuestion);
            return convertedQuestion;
        }
    }

    /**
     * Procesa la respuesta del jugador
     * @param {string} answer - Respuesta seleccionada
     */
    async processAnswer(answer) {
        if (!this.gameState.isGameRunning || !this.gameState.currentQuestion) {
            return;
        }

        // Calcular tiempo de respuesta
        const responseTime = this.config.timer - this.gameState.timeRemaining;

        // Parar temporizador
        this.stopTimer();

        const isCorrect = answer === this.gameState.currentQuestion.respuesta_correcta;
        this.gameState.questionsAnswered++;

        // Track respuesta en challenge
        if (window.trivialAnalytics) {
            window.trivialAnalytics.trackChallengeQuestion(
                this.gameState.questionsAnswered,
                this.gameState.timeRemaining,
                isCorrect,
                responseTime
            );
        }

        if (isCorrect) {
            this.gameState.correctAnswers++;
            this.gameState.streak++;
            this.gameState.score += this.calculateScore();
            
            // Track racha si es significativa
            if (window.trivialAnalytics && this.gameState.streak >= 3) {
                window.trivialAnalytics.trackChallengeStreak(
                    this.config.mode || 'survival',
                    this.gameState.streak,
                    'correct'
                );
            }
            
            // Track bonus por velocidad si respondi√≥ r√°pido
            if (responseTime <= 5 && window.trivialAnalytics) {
                const bonusPoints = Math.floor((5 - responseTime) * 10);
                window.trivialAnalytics.trackChallengeSpeedBonus(
                    this.config.mode || 'survival',
                    bonusPoints,
                    responseTime
                );
            }
            
            console.log('‚úÖ Respuesta correcta! Puntuaci√≥n:', this.gameState.score);
        } else {
            this.gameState.streak = 0;
            console.log('‚ùå Respuesta incorrecta. Streak perdido.');
        }

        // Disparar evento de respuesta procesada
        this.dispatchEvent('challengeAnswerProcessed', {
            isCorrect,
            correctAnswer: this.gameState.currentQuestion.respuesta_correcta,
            gameState: this.gameState
        });

        // Determinar si continuar o terminar
        await this.handleQuestionResult(isCorrect);
    }    /**
     * Maneja el resultado de una pregunta y decide el siguiente paso
     * @param {boolean} isCorrect - Si la respuesta fue correcta
     */
    async handleQuestionResult(isCorrect) {
        console.log(`üéØ Procesando resultado: ${isCorrect ? 'Correcto' : 'Incorrecto'}`);
        
        if (this.config.mode === 'survival') {
            await this.handleSurvivalResult(isCorrect);
        } else {
            // Modo por defecto: continuar siempre
            await this.handleDefaultResult(isCorrect);
        }
    }

    /**
     * Maneja el resultado en modo supervivencia
     * @param {boolean} isCorrect - Si la respuesta fue correcta
     */
    async handleSurvivalResult(isCorrect) {
        if (isCorrect) {
            console.log(`‚úÖ ¬°Supervivencia! Racha: ${this.gameState.streak}, Puntuaci√≥n: ${this.gameState.score}`);
            
            // Continuar con la siguiente pregunta despu√©s de una pausa
            setTimeout(async () => {
                if (this.gameState.isGameRunning && this.gameState.isAlive) {
                    await this.loadNextQuestion();
                    this.startTimer();
                }
            }, 2000);
            
        } else {
            console.log('üíÄ ¬°Game Over! Has fallado en modo supervivencia');
            
            // En modo supervivencia, un error termina el juego
            this.gameState.isAlive = false;
            this.gameState.lives = 0;
            
            // Disparar evento espec√≠fico de muerte en supervivencia
            this.dispatchEvent('survivalGameOver', {
                finalScore: this.gameState.score,
                questionsAnswered: this.gameState.questionsAnswered,
                correctAnswers: this.gameState.correctAnswers,
                maxStreak: this.gameState.streak,
                causeOfDeath: 'wrong_answer'
            });
            
            // Terminar el juego despu√©s de mostrar el resultado
            setTimeout(() => {
                this.endChallenge();
            }, 3000);
        }
    }

    /**
     * Maneja el resultado en modo por defecto (contin√∫a siempre)
     * @param {boolean} isCorrect - Si la respuesta fue correcta
     */
    async handleDefaultResult(isCorrect) {
        // L√≥gica original: continuar independientemente del resultado
        setTimeout(async () => {
            if (this.gameState.isGameRunning) {
                await this.loadNextQuestion();
                this.startTimer();
            }
        }, 2000);
    }    /**
     * Calcula la puntuaci√≥n basada en el tiempo restante y racha
     */
    calculateScore() {
        const baseScore = 100;
        
        // Si es tiempo ilimitado (timer = 0), no dar bonificaci√≥n de tiempo
        const timeBonus = (this.config.timer === 0) ? 0 : this.gameState.timeRemaining * 2;
        const streakBonus = this.gameState.streak * 10;
        const difficultyMultiplier = this.getDifficultyMultiplier();
        
        // Bonificaci√≥n especial por jugar sin l√≠mite de tiempo (menos puntos base)
        const unlimitedTimePenalty = (this.config.timer === 0) ? 0.8 : 1.0;

        return Math.floor((baseScore + timeBonus + streakBonus) * difficultyMultiplier * unlimitedTimePenalty);
    }    /**
     * Obtiene el multiplicador basado en la dificultad
     */
    getDifficultyMultiplier() {
        const multipliers = {
            easy: 1.0,
            medium: 1.2,
            hard: 1.5,
            random: 1.3 // Multiplicador promedio para dificultad aleatoria
        };
        
        // Si es dificultad aleatoria, usar el multiplicador de la dificultad efectiva actual
        let effectiveDifficulty = this.config.difficulty;
        if (this.config.difficulty === 'random' && this.gameState.currentQuestion) {
            // Usar la dificultad de la pregunta actual si est√° disponible
            effectiveDifficulty = this.gameState.currentQuestion.dificultad || 'medium';
        }
        
        return multipliers[effectiveDifficulty] || 1.0;
    }/**
     * Inicia el temporizador de la pregunta current
     */
    startTimer() {
        this.stopTimer(); // Asegurarse de limpiar cualquier temporizador previo

        // Si el tiempo est√° configurado a 0, no iniciar temporizador (tiempo ilimitado)
        if (this.config.timer === 0) {
            console.log('‚è≥ Modo sin l√≠mite de tiempo activado');
            this.gameState.timeRemaining = 0; // Indicar tiempo ilimitado
            
            // Disparar evento de actualizaci√≥n para mostrar "Sin l√≠mite"
            this.dispatchEvent('challengeTimerUpdate', {
                timeRemaining: 0,
                isUnlimited: true
            });
            return;
        }

        this.timerInterval = setInterval(() => {
            this.gameState.timeRemaining--;

            // Disparar evento de actualizaci√≥n del temporizador
            this.dispatchEvent('challengeTimerUpdate', {
                timeRemaining: this.gameState.timeRemaining,
                isUnlimited: false
            });

            // Si se acaba el tiempo
            if (this.gameState.timeRemaining <= 0) {
                this.handleTimeOut();
            }
        }, 1000);
    }

    /**
     * Detiene el temporizador current
     */
    stopTimer() {
        if (this.timerInterval) {
            clearInterval(this.timerInterval);
            this.timerInterval = null;
        }
    }

    /**
     * Maneja cuando se acaba el tiempo para responder
     */
    handleTimeOut() {
        console.log('‚è∞ Tiempo agotado!');
        this.stopTimer();
        
        // Procesar como respuesta incorrecta
        this.processTimeOut();
    }    /**
     * Procesa el timeout como respuesta incorrecta
     */
    async processTimeOut() {
        // Verificar que tenemos una pregunta actual
        if (!this.gameState.currentQuestion) {
            console.error('‚ùå processTimeOut: No hay pregunta actual');
            this.endChallenge();
            return;
        }

        this.gameState.questionsAnswered++;
        this.gameState.streak = 0;

        // Track timeout en analytics
        if (window.trivialAnalytics) {
            window.trivialAnalytics.trackChallengeTimeout(
                this.config.mode || 'survival',
                this.gameState.currentQuestion.categoria || 'unknown',
                this.config.timer || 20
            );
        }

        // Disparar evento de timeout
        this.dispatchEvent('challengeTimeOut', {
            correctAnswer: this.gameState.currentQuestion.respuesta_correcta,
            gameState: this.gameState
        });

        // En modo supervivencia, timeout tambi√©n termina el juego
        if (this.config.mode === 'survival') {
            console.log('üíÄ ¬°Game Over! Tiempo agotado en modo supervivencia');
            
            this.gameState.isAlive = false;
            this.gameState.lives = 0;
            
            // Disparar evento espec√≠fico de muerte por timeout
            this.dispatchEvent('survivalGameOver', {
                finalScore: this.gameState.score,
                questionsAnswered: this.gameState.questionsAnswered,
                correctAnswers: this.gameState.correctAnswers,
                maxStreak: this.gameState.streak,
                causeOfDeath: 'timeout'
            });
            
            // Terminar el juego
            setTimeout(() => {
                this.endChallenge();
            }, 3000);
        } else {
            // Continuar con la siguiente pregunta en otros modos
            await this.handleQuestionResult(false);
        }
    }

    /**
     * Termina el desaf√≠o actual
     */
    endChallenge() {
        console.log('üèÅ Finalizando desaf√≠o...');
        
        this.stopTimer();
        this.gameState.isGameRunning = false;
        this.isActive = false;

        const gameResults = {
            score: this.gameState.score,
            questionsAnswered: this.gameState.questionsAnswered,
            correctAnswers: this.gameState.correctAnswers,
            accuracy: this.gameState.questionsAnswered > 0 
                ? Math.round((this.gameState.correctAnswers / this.gameState.questionsAnswered) * 100) 
                : 0,
            maxStreak: this.gameState.streak,
            duration: Date.now() - this.gameState.gameStartTime,
            difficulty: this.config.difficulty
        };

        // Track finalizaci√≥n del desaf√≠o
        if (window.trivialAnalytics) {
            const timeUsed = Math.round(gameResults.duration / 1000);
            
            window.trivialAnalytics.trackChallengeComplete(
                this.config.mode || 'survival',
                gameResults.score,
                timeUsed,
                gameResults.correctAnswers,
                gameResults.questionsAnswered
            );
            
            // Track milestone si es un score alto
            if (gameResults.score >= 1000) {
                window.trivialAnalytics.trackMilestone(`challenge_high_score_${Math.floor(gameResults.score / 1000)}k`);
            }
            
            // Track dificultad vs rendimiento
            window.trivialAnalytics.trackChallengeDifficulty(
                this.config.mode || 'survival',
                this.config.difficulty,
                gameResults.accuracy
            );
        }

        // Disparar evento de fin de desaf√≠o
        this.dispatchEvent('challengeEnded', { results: gameResults });

        console.log('üìä Resultados del desaf√≠o:', gameResults);
        return gameResults;
    }

    /**
     * Pausa el desaf√≠o actual
     */
    pauseChallenge() {
        if (this.gameState.isGameRunning) {
            this.stopTimer();
            
            // Track pausa en analytics
            if (window.trivialAnalytics) {
                window.trivialAnalytics.trackChallengePause(
                    this.config.mode || 'survival',
                    this.gameState.questionsAnswered,
                    this.gameState.score
                );
            }
            
            this.dispatchEvent('challengePaused', { gameState: this.gameState });
            console.log('‚è∏Ô∏è Desaf√≠o pausado');
        }
    }

    /**
     * Reanuda el desaf√≠o pausado
     */
    resumeChallenge() {
        if (this.gameState.isGameRunning && this.gameState.currentQuestion) {
            this.startTimer();
            
            // Track reanudaci√≥n en analytics
            if (window.trivialAnalytics) {
                window.trivialAnalytics.trackChallengeResume(
                    this.config.mode || 'survival',
                    this.gameState.questionsAnswered,
                    this.gameState.score
                );
            }
            
            this.dispatchEvent('challengeResumed', { gameState: this.gameState });
            console.log('‚ñ∂Ô∏è Desaf√≠o reanudado');
        }
    }

    /**
     * Obtiene las estad√≠sticas actuales del desaf√≠o
     */
    getStats() {
        return {
            ...this.gameState,
            accuracy: this.gameState.questionsAnswered > 0 
                ? Math.round((this.gameState.correctAnswers / this.gameState.questionsAnswered) * 100) 
                : 0,
            elapsedTime: this.gameState.gameStartTime 
                ? Date.now() - this.gameState.gameStartTime 
                : 0
        };
    }

    /**
     * Dispara un evento personalizado
     * @param {string} eventName - Nombre del evento
     * @param {Object} data - Datos del evento
     */
    dispatchEvent(eventName, data) {
        const event = new CustomEvent(eventName, { detail: data });
        document.dispatchEvent(event);
    }

    /**
     * Limpia recursos y resetea el motor
     */
    cleanup() {
        this.stopTimer();
        this.resetGameState();
        this.isActive = false;
        console.log('üßπ Motor de desaf√≠o limpiado');
    }

    /**
     * Prueba la conexi√≥n con la API
     */
    async testApiConnection() {
        try {
            console.log('üîç Probando conexi√≥n con la API...');
            console.log('ApiClient instance:', this.apiClient);
            
            // Probar una categor√≠a simple
            const testQuestions = await this.apiClient.getQuestions('historia', 'easy', 1);
            console.log('‚úÖ Prueba de API exitosa:', testQuestions);
            return true;
        } catch (error) {
            console.error('‚ùå Prueba de API fall√≥:', error);
            return false;
        }
    }    /**
     * Crea una pregunta de prueba para testing
     */    createTestQuestion(effectiveDifficulty = 'medium') {
        const testQuestions = [
            {
                pregunta: "¬øCu√°l es la capital de Francia?",
                opciones: ["Par√≠s", "Londres", "Madrid", "Roma"],
                respuesta_correcta: "Par√≠s",
                categoria: "geografia",
                dificultad: effectiveDifficulty,
                fuente: "test",
                // Incluir versi√≥n original en ingl√©s para testing
                originalQuestion: "What is the capital of France?",
                originalAnswers: ["Paris", "London", "Madrid", "Rome"]
            },
            {
                pregunta: "¬øEn qu√© a√±o termin√≥ la Segunda Guerra Mundial?",
                opciones: ["1945", "1944", "1946", "1943"],
                respuesta_correcta: "1945",
                categoria: "historia",
                dificultad: effectiveDifficulty,
                fuente: "test",
                // Incluir versi√≥n original en ingl√©s para testing
                originalQuestion: "In what year did World War II end?",
                originalAnswers: ["1945", "1944", "1946", "1943"]
            },
            {
                pregunta: "¬øCu√°l es el planeta m√°s grande del sistema solar?",
                opciones: ["J√∫piter", "Saturno", "Tierra", "Marte"],
                respuesta_correcta: "J√∫piter",                categoria: "ciencia",
                dificultad: effectiveDifficulty,
                fuente: "test",
                // Incluir versi√≥n original en ingl√©s para testing
                originalQuestion: "What is the largest planet in the solar system?",
                originalAnswers: ["Jupiter", "Saturn", "Earth", "Mars"]
            }
        ];
        
        const selectedQuestion = testQuestions[Math.floor(Math.random() * testQuestions.length)];
        console.log('üß™ Pregunta de prueba creada con versiones original y traducida:', selectedQuestion);
        return selectedQuestion;
    }

    /**
     * Diagn√≥stico completo del sistema
     */
    async runDiagnostic() {
        console.log('üîç === DIAGN√ìSTICO DEL MODO DESAF√çO ===');
        
        // 1. Verificar configuraci√≥n
        console.log('üìã Configuraci√≥n actual:', this.config);
        
        // 2. Verificar ApiClient
        console.log('üîå ApiClient:', {
            exists: !!this.apiClient,
            type: typeof this.apiClient,
            hasGetQuestions: this.apiClient && typeof this.apiClient.getQuestions === 'function'
        });
        
        // 3. Probar carga de pregunta
        try {
            console.log('üß™ Probando carga de pregunta...');
            await this.loadNextQuestion();
            console.log('‚úÖ Carga de pregunta exitosa');
            console.log('üìù Pregunta actual:', this.gameState.currentQuestion);
        } catch (error) {
            console.error('‚ùå Error en carga de pregunta:', error);
        }
        
        // 4. Verificar estado del juego
        console.log('üéÆ Estado del juego:', this.gameState);
        
        console.log('üèÅ === FIN DEL DIAGN√ìSTICO ===');
    }

    /**
     * Selecciona una dificultad aleatoria si est√° configurada como 'random'
     */
    getEffectiveDifficulty() {
        if (this.config.difficulty === 'random') {
            const difficulties = ['easy', 'medium', 'hard'];
            const randomDifficulty = difficulties[Math.floor(Math.random() * difficulties.length)];
            console.log(`üé≤ Dificultad aleatoria seleccionada: ${randomDifficulty}`);
            return randomDifficulty;
        }
        return this.config.difficulty;
    }

    /**
     * Abandona el desaf√≠o actual
     */
    abandonChallenge() {
        if (this.gameState.isGameRunning) {
            console.log('üö™ Abandonando desaf√≠o...');
            
            // Track abandono en analytics
            if (window.trivialAnalytics) {
                window.trivialAnalytics.trackChallengeAbandon(
                    this.config.mode || 'survival',
                    this.gameState.questionsAnswered,
                    this.gameState.score,
                    Math.round((Date.now() - this.gameState.gameStartTime) / 1000)
                );
            }
            
            this.stopTimer();
            this.gameState.isGameRunning = false;
            this.isActive = false;
            
            this.dispatchEvent('challengeAbandoned', { 
                gameState: this.gameState,
                finalScore: this.gameState.score
            });
        }
    }
}

// Exportar para uso global
window.ChallengeEngine = ChallengeEngine;
